#!/usr/bin/env node
// Generate SVG path data for a wordmark using a local WOFF2 font.
// Outputs: tmp/react-pokedex-path.txt and tmp/react-pokedex.svg

import {Font} from 'fonteditor-core'
import fs from 'node:fs'
import path from 'node:path'
import url from 'node:url'
import opentype from 'opentype.js'

const __dirname = path.dirname(url.fileURLToPath(import.meta.url))

// Config (tweak as needed)
const TEXT = process.env.WORDMARK_TEXT || 'React PokÃ©dex'
// viewBox is 227 x 36; logo mark occupies ~0..36, text baseline ~26
const START_X = Number(process.env.WORDMARK_X ?? 56)
const BASELINE_Y = Number(process.env.WORDMARK_BASELINE ?? 26)
const FONT_SIZE = Number(process.env.WORDMARK_SIZE ?? 18)

const fontWoff2 = path.resolve(__dirname, '../src/fonts/lexend.woff2')
const outDir = path.resolve(__dirname, '../tmp')
const outTxt = path.join(outDir, 'react-pokedex-path.txt')
const outSvg = path.join(outDir, 'react-pokedex.svg')
const wordmarkTs = path.resolve(__dirname, '../src/components/wordmark-path.ts')

async function main() {
  if (!fs.existsSync(fontWoff2)) {
    console.error(`Font not found: ${fontWoff2}`)
    process.exit(1)
  }

  if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true })

  const woff2Buf = fs.readFileSync(fontWoff2)
  // Convert WOFF2 -> TTF buffer via fonteditor-core
  const font = Font.create(woff2Buf, { type: 'woff2' })
  const ttfBuf = font.write({ type: 'ttf' })

  // Parse with opentype.js
  const ot = opentype.parse(Buffer.from(ttfBuf))

  // Verify glyph coverage (basic check)
  for (const ch of TEXT) {
    if (ch === ' ') continue
    const glyph = ot.charToGlyph(ch)
    if (!glyph || glyph.unicode === undefined) {
      console.warn(`Warning: missing glyph for '${ch}' (U+${ch.codePointAt(0).toString(16)})`)
    }
  }

  // Build path
  const p = ot.getPath(TEXT, START_X, BASELINE_Y, FONT_SIZE, { kerning: true })
  // Use 2 decimal places to keep size small yet crisp
  const d = p.toPathData ? p.toPathData(2) : pathCommandsToD(p.commands)

  fs.writeFileSync(outTxt, d, 'utf8')

  const width = ot.getAdvanceWidth(TEXT, FONT_SIZE, { kerning: true })
  const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 227 36" fill="none"><path d="${d}" fill="#000"/></svg>`
  fs.writeFileSync(outSvg, svg, 'utf8')

  const ts = `// Auto-generated by scripts/generate-wordmark.mjs\n` +
    `// DO NOT EDIT MANUALLY. Run: pnpm gen:wordmark\n\n` +
    `export const WORDMARK_PATH_D = ${JSON.stringify(d)} as const\n`
  fs.writeFileSync(wordmarkTs, ts, 'utf8')

  console.log('Generated:')
  console.log(` - ${path.relative(process.cwd(), outTxt)}`)
  console.log(` - ${path.relative(process.cwd(), outSvg)} (preview)`) 
  console.log(` - ${path.relative(process.cwd(), wordmarkTs)} (imported by Logo.tsx)`) 
  console.log(`Metrics: startX=${START_X}, baselineY=${BASELINE_Y}, fontSize=${FONT_SIZE}, approxWidth=${Math.round(width)}`)
}

function pathCommandsToD(commands) {
  return commands
    .map((cmd) => {
      switch (cmd.type) {
        case 'M':
          return `M${round(cmd.x)} ${round(cmd.y)}`
        case 'L':
          return `L${round(cmd.x)} ${round(cmd.y)}`
        case 'C':
          return `C${round(cmd.x1)} ${round(cmd.y1)} ${round(cmd.x2)} ${round(cmd.y2)} ${round(cmd.x)} ${round(cmd.y)}`
        case 'Q':
          return `Q${round(cmd.x1)} ${round(cmd.y1)} ${round(cmd.x)} ${round(cmd.y)}`
        case 'Z':
          return 'Z'
        default:
          return ''
      }
    })
    .join(' ')
}

function round(n) {
  return Math.round(n * 100) / 100
}

main().catch((err) => {
  console.error(err)
  process.exit(1)
})
